clear; 
clc; 
close all;

%% Problem1 Analyze the frequency domain characteristics of Rectangular, Hanning, and Hamming windows.
%% --- Parameters ---
N = 1024;   % Window length (should be large, e.g., 512 or 1024, for good frequency resolution)
% Define the relative path to the audio file
relative_audio_path = '..\Data\Test\C\C02n_1.wav'; 
relative_path_to_plots = '..\Data\Results\plot'; % Define the relative path from Src to the target folder

% Extract info
[Fs, bitDepth, bitRate, numChannels, totalSamples] = get_audio_info(relative_audio_path);

% Example of using the extracted data
if ~isempty(Fs)
    fprintf('\nAnalysis using Fs = %d Hz and Bit Rate = %d bps is ready.\n', Fs, bitRate);
end
%{
%% --- 1. Define Windows (Time Domain) ---

% 1. Generate Window Vectors (using your first function)
[W_Rec, W_Han, W_Ham, n] = generate_windows(N);

% 2. Plot Time Domain and capture the figure handle
time_fig_handle = plot_time_windows(n, W_Rec, W_Han, W_Ham);

% 3. Save the Time Domain figure
figure_to_png(time_fig_handle, 'problem1_time_domain',relative_path_to_plots); 

%% --- 2. Define Windows (Frequency Domain) ---
% --- 1. Compute Frequency Responses (Log Magnitude dB) ---
[f, dB_Rec_shifted, dB_Han_shifted, dB_Ham_shifted] = compute_freq_response(Fs, W_Rec, W_Han, W_Ham);

% --- 2. Plotting ---
freq_fig_handle = plot_freq_windows(Fs, f, dB_Rec_shifted, dB_Han_shifted, dB_Ham_shifted);

% 3. Save the Frequency Domain figure
figure_to_png(freq_fig_handle, 'problem1_freq_domain',relative_path_to_plots); 

%% Problem2 LPC Analysis based on given R data
% --- 1. Define Input Data for Problem 2 ---

% R_vector = [R(0), R(1), R(2), ..., R(p)]
R_matrix2 = [1, 0.7, 0.4];
LPC_ORDER_p2 = length(R_matrix2) - 1; % Should be 2
frames=[1,2,3];

% print it
print_R_matrix(R_matrix2);

fprintf('--- Problem 2: LPC (p=%d) Solution Verification ---\n',LPC_ORDER_p2);


% --- 5. Call the generalized solver function  ---
[A_matrix2, E_vector2,P2] = lpc_matrix_solution(R_matrix2);

% --- 7. Display Results ---
problem2_fig_handle = print_lpc_matrix_results(frames, A_matrix2, E_vector2, R_matrix2);

%  Save the frame grid figure
figure_to_png(problem2_fig_handle, 'problem2_sol',relative_path_to_plots); 


%% Problem 3 Frame Analysis based on given S data
% Problem: s[n] = [1, 4, 0, -4, -1, 2, 4, -1, 2, 5], Frame Size = 6, Overlap = 2, LPC Order P = 2.
% --- 1. Define Input Data for Problem 3 ---
% Signal (s0 to s9)
s = [1, 4, 0, -4, -1, 2, 4, -1, 2, 5];

frame_length = 6; % Frame Size
P = 2; % LPC Order
overlap = 2;
frame_shift = frame_length - overlap;

fprintf('--- Problem 3a: LPC Analysis for Frame Size N=%d and Order P=%d ---\n', frame_length, P);


% --- 2. Call the generalized solver function  ---
frames3a = extract_frames(s, frame_length, frame_shift);

% --- 3. Display Results ---
% Display the full signal with markers 
frame_fig_handle = plot_frames(s, frames3a, frame_length, frame_shift, Fs);

%  Save the frame figure
figure_to_png(frame_fig_handle, 'problem3a_frames',relative_path_to_plots); 

% Display individual frames in a grid 
frame_grid_handle = plot_frame_grid(frames3a, Fs);

%  Save the frame grid figure
figure_to_png(frame_grid_handle, 'problem3a_frames_gird',relative_path_to_plots); 

% --- 4. calculate autocorrelation  ---
R_matrix3a = calculate_autocorr_frames(frames3a, P);

% print it
print_R_matrix(R_matrix3a);

fprintf('--- Problem 3a: LPC (p=%d) Solution Verification ---\n',P);

% --- 5. Call the generalized solver function  ---
[A_matrix3a, E_vector3a,P3a] = lpc_matrix_solution(R_matrix3a);

% --- 7. Display Results ---
problem3a_fig_handle = print_lpc_matrix_results(frames3a, A_matrix3a, E_vector3a, R_matrix3a);

%  Save the frame grid figure
figure_to_png(problem3a_fig_handle, 'problem3a_sol',relative_path_to_plots); 

%% Problem 3b: LPC Analysis with Pre-emphasis (alpha=0.96)
% --- 1. Define Input Data for Problem 3 ---
% Signal: s[n] = [1, 4, 0, -4, -1, 2, 4, -1, 2, 5], Frame Size = 6, Overlap = 2, LPC Order P = 2.
% Pre-emphasis constant: alpha = 0.96
s = [1, 4, 0, -4, -1, 2, 4, -1, 2, 5];

frame_length = 6; % Frame Size
P = 2; % LPC Order
overlap = 2;
frame_shift = frame_length - overlap;
pre_alpha = 0.96;

% apply pre emmphasis
s_emph = pre_emphasis_signal(s, pre_alpha);

fprintf('--- Problem 3b: LPC Analysis with Pre-emphasis constant: alpha = %.2f  for Frame Size N=%d and Order P=%d ---\n',pre_alpha, frame_length, P);

% --- 2. Call the generalized solver function  ---
frames3b = extract_frames(s_emph, frame_length, frame_shift);

% --- 3. Display Results ---
% Display the full signal with markers 
frame_fig_handle = plot_frames(s_emph, frames3b, frame_length, frame_shift, Fs);

%  Save the frame figure
figure_to_png(frame_fig_handle, 'problem3b_frames',relative_path_to_plots); 

% Display individual frames in a grid 
frame_grid_handle = plot_frame_grid(frames3b, Fs);

%  Save the frame grid figure
figure_to_png(frame_grid_handle, 'problem3b_frames_gird',relative_path_to_plots); 

% --- 4. calculate autocorrelation  ---
R_matrix3b = calculate_autocorr_frames(frames3b, P);

% print it
print_R_matrix(R_matrix3b);

fprintf('--- Problem 3b: LPC (p=%d) Solution Verification ---\n',P);

% --- 5. Call the generalized solver function  ---
[A_matrix3b, E_vector3b,P3b] = lpc_matrix_solution(R_matrix3b);

% --- 7. Display Results ---
problem3b_fig_handle = print_lpc_matrix_results(frames3b, A_matrix3b, E_vector3b, R_matrix3b);

%  Save the frame grid figure
figure_to_png(problem3b_fig_handle, 'problem3b_sol',relative_path_to_plots); 


%% Problem 4: Formant and Bandwidth Estimation from All-Pole System
% An 8th-order all-pole system modeled by 4 complex-conjugate pole pairs.
% Given poles (4 complex-conjugate pairs)
% The system function is H(z) = 1 / A(z), where A(z) is the polynomial whose roots are these poles.
Poles = [
    0.965500 + 0.192050i; 0.965500 - 0.192050i; % p1,2
    0.812108 + 0.542633i; 0.812108 - 0.542633i; % p3,4
    0.534176 + 0.799451i; 0.534176 - 0.799451i; % p5,6
    0.183930 + 0.924681i; 0.183930 - 0.924681i  % p7,8
];
% --- Part a: Calculate and Plot the magnitude spectrum in dB  ---

% 1. Call the function to calculate A_coeffs and H_mag
[A_coeffs, H_mag, W] = calculate_all_pole_response(Poles, Fs, N);

% --- Part a: Plot the magnitude spectrum in dB ---
problem4_fig_handle = plot_pole_spectrum(Fs, W, H_mag);


% --- Part b: Estimate formants and bandwidths ---
[Formants_Hz, Bandwidths_Hz] = estimate_and_plot_formants(Poles, Fs, H_mag);

%  Save the magnitude spectrum figure
figure_to_png(problem4_fig_handle, 'problem4_plot',relative_path_to_plots);

plot_BW_poles(Poles, Fs);

%%  Problem 5: Recover Poles from A(z)
A_coeffs_verify = [1.0, -4.9914283, 12.3717836, -19.81615903, 22.40030463,...
    -18.3112730, 10.60283765, -3.99936958, 0.75965617];
Recovered_Poles = recover_poles_from_coeffs(A_coeffs_verify);

% 1. Call the function to verify A_coeffs and H_mag
[Recovered_A_coeffs, Recovered_H_mag, Recovered_W] = calculate_all_pole_response(Recovered_Poles, Fs, N);

% --- Part a: Plot the magnitude spectrum in dB ---
problem4_fig_handle = plot_pole_spectrum(Fs, Recovered_W, Recovered_H_mag);

% --- Estimate formants and bandwidths ---
[Recovered_Formants_Hz, Recovered_Bandwidths_Hz] = estimate_and_plot_formants(Recovered_Poles, Fs, Recovered_H_mag);

%  Save the magnitude spectrum figure
figure_to_png(problem4_fig_handle, 'problem5_plot',relative_path_to_plots);

fig_handle =plot_BW_poles(Recovered_Poles, Fs);


%% -------------------------------------------------------------------------
%                               Problem 6
%                  Speech Vocoder (Analysis + Synthesis)
% -------------------------------------------------------------------------
fprintf('\n--- Problem 6: Speech Vocoder (Analysis + Synthesis) ---\n');

% Input and output relative paths (match your style)
relative_audio_p6 = '..\Data\Problem 6\MyVoice.wav';
results_folder_p6  = '..\Data\Problem 6\Results';
plots_folder_p6    = fullfile(results_folder_p6, 'plot');

% Create results folders if not exist
current_file_path = mfilename('fullpath');
current_dir = fileparts(current_file_path);
full_results_dir = fullfile(current_dir, results_folder_p6);
full_plots_dir   = fullfile(current_dir, plots_folder_p6);
if ~exist(full_results_dir,'dir'), mkdir(full_results_dir); end
if ~exist(full_plots_dir,'dir'), mkdir(full_plots_dir); end

% Parameters (sensible defaults, tweakable)
params.Fs_target = 16000;
params.frame_ms = 30;
params.hop_ms = 10;
params.preemph = 0.97;
params.lpc_order = 14;  % practical for 16kHz
params.f0_min = 50;
params.f0_max = 500;
params.center_clip_pct = 0.35; % for center-clipping pitch (0..1)
params.zcr_threshold = 0.15;
params.acf_threshold = 0.35;

% Read audio
try
    [x_raw, Fs_raw] = audioread(relative_audio_p6);
catch ME
    error('Cannot read audio. Make sure file exists at: %s\nError: %s', relative_audio_p6, ME.message);
end
if size(x_raw,2) > 1, x_raw = mean(x_raw,2); end
% resample if needed
if Fs_raw ~= params.Fs_target
    x = resample(x_raw, params.Fs_target, Fs_raw);
    Fs = params.Fs_target;
else
    x = x_raw;
    Fs = Fs_raw;
end
x = x / max(abs(x)) * 0.98; % normalize
audiowrite(fullfile(full_results_dir,'original_clean.wav'), x, Fs);

% Preprocess: pre-emphasis, framing, windowing
[frames, win, N, hop] = speech_preprocess(x, Fs, params);

% Analysis: LPC, gain
[LPCCoef, gain_vec] = speech_lpc_analysis(frames, params.lpc_order);

% Pitch estimation: basic ACF + improved center-clipped ACF + cepstral fallback
[f0_basic, acf_peak_basic]     = speech_pitch_estimation(frames, Fs, params, 'basic');
[f0_cc,   acf_peak_cc]         = speech_pitch_estimation(frames, Fs, params, 'centerclip');
[f0_cep,  cep_strength]        = speech_pitch_estimation(frames, Fs, params, 'cepstrum');

% Voicing decision: combine energy, zcr, and center-clipped ACF strength
voiced_basic  = speech_voicing_decision(frames, f0_basic, acf_peak_basic, params);
voiced_improved = speech_voicing_decision(frames, f0_cc, acf_peak_cc, params);

% Synthesis Basic (A): impulse train + noise, strict voiced_basic
y_basic = speech_vocoder_synthesis_basic(LPCCoef, gain_vec, f0_basic, voiced_basic, win, hop, Fs, params);
audiowrite(fullfile(full_results_dir,'vocoder_basic.wav'), y_basic./max(abs(y_basic))*0.98, Fs);

% Synthesis Improved (B): center-clipped pitch + smoothed LPC + improved voicing
% perform simple envelope smoothing of LPC across frames
LPCCoef_smoothed = smooth_lpc_coeffs(LPCCoef, 3); % 3-frame median
y_improved = speech_vocoder_synthesis_basic(LPCCoef_smoothed, gain_vec, f0_cc, voiced_improved, win, hop, Fs, params);
audiowrite(fullfile(full_results_dir,'vocoder_improved.wav'), y_improved./max(abs(y_improved))*0.98, Fs);

% Synthesis Residual (C): extract residual per frame and reuse/resample it (mixed excitation)
y_residual = speech_vocoder_synthesis_residual(frames, LPCCoef, gain_vec, f0_cc, voiced_improved, win, hop, Fs, params);
audiowrite(fullfile(full_results_dir,'vocoder_residual.wav'), y_residual./max(abs(y_residual))*0.98, Fs);

% -------------------------------------------------------------------------
% Plots: spectrograms and pitch track 
% -------------------------------------------------------------------------

problem6_spect_fig_handle =plot_vocoder_spectrograms(x, y_basic, y_improved, y_residual, Fs);

% save the figure
figure_to_png(problem6_spect_fig_handle, 'vocoder_spectrogram_comparison', plots_folder_p6);


% Pitch track figure (plot f0_cc and voiced)
problem6_pitch_fig_handle =plot_pitch_comparison(f0_basic, f0_cc, f0_cep, hop, Fs);

% Save the figure
figure_to_png(problem6_pitch_fig_handle,'pitch_track_comparison', plots_folder_p6);

% calculate error
[error_basic, error_improved, error_residual, SDR_basic, SDR_improved, SDR_residual] =...
    calculate_vocoder_error(x, y_basic, y_improved, y_residual);

% plot error
problem6_error_fig_handle = ...
    plot_vocoder_metrics_table(error_basic, error_improved, error_residual, SDR_basic, SDR_improved, SDR_residual);

% Save the figure
figure_to_png(problem6_error_fig_handle, 'vocoder_performance_metrics_table', plots_folder_p6);

fprintf('Problem 6 finished. Outputs saved to: %s\n', full_results_dir);
%}

%% -------------------------------------------------------------------------
% Problem 7: Speech Digit + Speaker-Type Recognition (MFCC + DTW)
% -------------------------------------------------------------------------


% ================= PATHS ====================
TRAIN_DIR = 'D:\project\DSP\DSP_Speech_Processing\Data\Train';
TEST_DIR  = 'D:\project\DSP\DSP_Speech_Processing\Data\Test';

RESULTS_DIR = fullfile(fileparts(TRAIN_DIR), 'Results', 'Problem7');
PLOT_DIR = fullfile(RESULTS_DIR, 'plot');

if ~exist(RESULTS_DIR,'dir'), mkdir(RESULTS_DIR); end
if ~exist(PLOT_DIR,'dir'), mkdir(PLOT_DIR); end

% ================= MFCC PARAMETERS ====================
params.fs_target = 16000;
params.frame_ms = 25;
params.hop_ms = 10;
params.num_ceps = 13;
params.use_delta = true;
params.normalize = true;

dtw_opts.use_builtin = exist('dtw','file') ~= 0;

% ================= LABEL SETS ====================
TYPE_LIST  = {'C','M','F','U'};     % Speaker categories
DIGIT_LIST = {'0','1','2','3','4','5','6','7','8','9'};

% ================= LOAD TRAIN SET (with caching) ====================
train_cache = fullfile(RESULTS_DIR, 'train_mfcc_cache.mat');

if exist(train_cache, 'file')
    fprintf("\nLoading TRAIN MFCC cache...\n");
    S = load(train_cache);
    train_feats  = S.train_feats;
    train_types  = S.train_types;
    train_digits = S.train_digits;

else
    fprintf("\nExtracting MFCC for TRAIN set (no cache found)...\n");
    [train_feats, train_types, train_digits] = load_dataset(TRAIN_DIR, params);

    fprintf("Saving TRAIN MFCC cache...\n");
    save(train_cache, 'train_feats', 'train_types', 'train_digits', '-v7.3');
end


% ================= LOAD TEST SET (with caching) ====================
test_cache = fullfile(RESULTS_DIR, 'test_mfcc_cache.mat');

if exist(test_cache, 'file')
    fprintf("\nLoading TEST MFCC cache...\n");
    S = load(test_cache);
    test_feats  = S.test_feats;
    test_types  = S.test_types;
    test_digits = S.test_digits;

else
    fprintf("\nExtracting MFCC for TEST set (no cache found)...\n");
    [test_feats, test_types, test_digits] = load_dataset(TEST_DIR, params);

    fprintf("Saving TEST MFCC cache...\n");
    save(test_cache, 'test_feats', 'test_types', 'test_digits', '-v7.3');
end

% === Load cached MFCCs ===
load(fullfile(RESULTS_DIR, "train_mfcc_cache.mat"), ...
    "train_feats", "train_types", "train_digits");

% Check if the clustering model already exists
if ~exist('clustering_model.mat', 'file')
    fprintf("Clustering model not found. Generating and training model...\n");
    
    % === Create embeddings (mean MFCC per file) ===
    Ntrain = numel(train_feats);
    
    % Initialize embeddings matrix based on the number of training samples
    % and the desired number of MFCC coefficients (params.num_ceps, typically 13)
    embeddings = zeros(Ntrain, params.num_ceps);
    
    for i = 1:Ntrain
        mfcc = train_feats{i};
        % Calculate the mean of the first params.num_ceps coefficients
        embeddings(i,:) = mean(mfcc(:,1:params.num_ceps), 1);
    end
    
    % === Train Speaker-Type Clustering (e.g., gender, accent, speaker ID) ===
    k_type = 4; % Assuming 4 types/clusters
    fprintf('Training Speaker-Type Clustering (K=%d)...\n', k_type);
    [idx_type, C_type] = kmeans(embeddings, k_type, 'Replicates', 20);
    
    % Majority voting to assign cluster label (type_labels)
    type_labels = cell(k_type,1);
    for c = 1:k_type
        cluster_members = train_types(idx_type == c);
        % Find the most frequent categorical label in the cluster
        type_labels{c} = mode(categorical(cluster_members));
    end
    
    %  === Train Digit Clustering (10 digits) ===
    k_digit = 10; % 10 digits (0-9)
    fprintf('Training Digit Clustering (K=%d)...\n', k_digit);
    [idx_digit, C_digit] = kmeans(embeddings, k_digit, 'Replicates', 20);
    
    % Majority voting to assign cluster label (digit_labels)
    digit_labels = cell(k_digit,1);
    for c = 1:k_digit
        cluster_members = train_digits(idx_digit == c);
        digit_labels{c} = mode(categorical(cluster_members));
    end
    
    % === Save model ===
    % Saves the cluster centers (C) and the assigned labels for both tasks
    save("clustering_model.mat", ...
        "C_type", "type_labels", ...
        "C_digit", "digit_labels", ...
        "params");
    fprintf("Clustering model saved to clustering_model.mat.\n");

else
    % Load the model if it exists
    fprintf("Clustering model found. Loading saved model...\n");
    load("clustering_model.mat", "C_type", "type_labels", "C_digit", "digit_labels", "params");
    fprintf("Clustering model loaded successfully.\n");
end

% Load test MFCCs
load(fullfile(RESULTS_DIR, "test_mfcc_cache.mat"), ...
     "test_feats", "test_types", "test_digits");


Ntest = numel(test_feats);
pred_type  = cell(Ntest,1);
pred_digit = cell(Ntest,1);

for i = 1:Ntest
    mfcc = test_feats{i};
    embedding = mean(mfcc(:,1:params.num_ceps),1);

    % Predict type
    [~, type_idx] = min(pdist2(embedding, C_type));
    pred_type{i} = type_labels{type_idx};

    % Predict digit
    [~, digit_idx] = min(pdist2(embedding, C_digit));
    pred_digit{i} = digit_labels{digit_idx};
end

% ---- convert all to strings (critical fix) ----
test_types  = string(test_types);
pred_type   = string(pred_type);

test_digits = string(test_digits);
pred_digit  = string(pred_digit);

% Confusion matrices
% ---- Type Confusion ----
fig1 = figure;
confusionchart(categorical(test_types), categorical(pred_type));
title("Speaker Type Recognition (Clustering)");
saveas(fig1, fullfile(PLOT_DIR, "type_confusion.png"));

% ---- Digit Confusion ----
fig2 = figure;
confusionchart(categorical(test_digits), categorical(pred_digit));
title("Digit Recognition (Clustering)");
saveas(fig2, fullfile(PLOT_DIR, "digit_confusion.png"));


% --- Save CSV Results ---
% Create a table from the true labels and the predictions
T = table(test_types, pred_type, test_digits, pred_digit, ...
          'VariableNames', {'TrueType', 'PredictedType', 'TrueDigit', 'PredictedDigit'});
          
% Write the table to a CSV file in the RESULTS_DIR
writetable(T, fullfile(RESULTS_DIR, "Problem7_results.csv"));
fprintf("Results table saved to: %s\n", fullfile(RESULTS_DIR, "Problem7_results.csv"));
fprintf("\nProblem 7 completed. Confusion matrices saved to:\n%s\n", PLOT_DIR);



%% --- Functions---
% window generation function
function [W_Rec, W_Han, W_Ham, n] = generate_windows(N)
% GENERATE_WINDOWS Creates Rectangular, Hanning, and Hamming window vectors.
%
%   [W_Rec, W_Han, W_Ham] = generate_windows(N)
%
%   Inputs:
%       N: Window length (e.g., 1024).
%
%   Outputs:
%       W_Rec: Rectangular window vector.
%       W_Han: Hanning window vector (0.5 - 0.5 * cos(2*pi*n/N)).
%       W_Ham: Hamming window vector (0.54 - 0.46 * cos(2*pi*n/N)).

    % 1. Create time indices (0 to N-1)
    n = 0:N-1;
   


    % 2. Rectangular Window: WRec = 1
    W_Rec = ones(1, N);
    
    % 3. Hanning Window: WHan = 0.5 – 0.5 cos(2πn/N)
    W_Han = 0.5 - 0.5 * cos(2*pi*n/N);
   
    
    % 4. Hamming Window: WHam = 0.54 – 0.46cos(2πn/N)
    W_Ham = 0.54 - 0.46 * cos(2*pi*n/N);


end
%% ---plot windows in time---
function fig = plot_time_windows(n, W_Rec, W_Han, W_Ham)
% PLOT_TIME_WINDOWS Plots Rectangular, Hanning, and Hamming windows in the time domain.
%
%   fig = plot_time_windows(n, W_Rec, W_Han, W_Ham)
%
%   Inputs:
%       n: Time index vector (e.g., 0:N-1).
%       W_Rec: Rectangular window vector.
%       W_Han: Hanning window vector.
%       W_Ham: Hamming window vector.
%
%   Output:
%       fig: The handle of the created MATLAB figure.

    N = length(n);

    % Create the figure and capture its handle
    fig = figure('Name', 'Window Functions in Time Domain');
    
    % --- X-AXIS LIMIT DEFINITION ---
    X_START = n(1);       % 0
    X_END = n(end);       % N-1 (e.g., 1023)
    
    % Subplot 1: Rectangular Window
    subplot(3, 1, 1);
    plot(n, W_Rec, 'b', 'LineWidth', 1.5);
    title('Rectangular Window ($W_{Rec}$)', 'Interpreter', 'latex');
    ylabel('Amplitude');
    grid on;
    ylim([0 1.1]);
    xlim([X_START X_END]); % <--- Explicitly set X limit
    
    % Subplot 2: Hanning Window
    subplot(3, 1, 2);
    plot(n, W_Han, 'r', 'LineWidth', 1.5);
    title('Hanning Window ($W_{Han}$)', 'Interpreter', 'latex');
    ylabel('Amplitude');
    grid on;
    ylim([0 1.1]);
    xlim([X_START X_END]); % <--- Explicitly set X limit
    
    % Subplot 3: Hamming Window
    subplot(3, 1, 3);
    plot(n, W_Ham, 'g', 'LineWidth', 1.5);
    title('Hamming Window ($W_{Ham}$)', 'Interpreter', 'latex');
    xlabel('Sample Index ($n$)', 'Interpreter', 'latex');
    ylabel('Amplitude');
    grid on;
    ylim([0 1.1]);
    xlim([X_START X_END]); % <--- Explicitly set X limit
    
    % Adjust layout for better visualization
    sgtitle(['Time Domain Representation of Windows (N=', num2str(N), ')'], 'FontSize', 14);
end
%% ---Get Audio Info---
function [Fs, bitDepth, bitRate, numChannels, totalSamples] = get_audio_info(audio_file_path)
% GET_AUDIO_INFO Extracts metadata (Fs, bit depth, bit rate, etc.) from a WAV audio file.
%
%   [Fs, bitDepth, bitRate, numChannels, totalSamples] = get_audio_info(audio_file_path)
%
%   Inputs:
%       audio_file_path: Full path to the audio file (e.g., '..\Data\Test\C02n_1.wav').
%
%   Outputs:
%       Fs: Sampling frequency (Hz).
%       bitDepth: Number of bits per sample.
%       bitRate: Data rate (bits per second).
%       numChannels: Number of audio channels (e.g., 1 for mono, 2 for stereo).
%       totalSamples: Total number of samples in the file.
%

    try
        % Use audioinfo to read the metadata without loading the full audio data
        info = audioinfo(audio_file_path);
        
        % Extract required information
        Fs = info.SampleRate;             % Sampling Frequency (Hz)
        bitDepth = info.BitsPerSample;    % Bits per Sample
        numChannels = info.NumChannels;   % Number of Channels (1=mono, 2=stereo)
        totalSamples = info.TotalSamples; % Total number of samples
        
        % Calculate Bit Rate (Data Rate)
        % Bit Rate = Fs * Bits Per Sample * Number of Channels
        bitRate = Fs * bitDepth * numChannels;
        
        % Display the extracted information
        fprintf('--- Audio File Information ---\n');
        fprintf('File: %s\n', audio_file_path);
        fprintf('Sampling Frequency (Fs): %d Hz\n', Fs);
        fprintf('Bits Per Sample (Bit Depth): %d bits\n', bitDepth);
        fprintf('Number of Channels: %d\n', numChannels);
        fprintf('Total Samples: %d\n', totalSamples);
        fprintf('Calculated Bit Rate: %d bits/s\n', bitRate);
        fprintf('------------------------------\n');
        
    catch ME
        % Handle file not found or other errors gracefully
        fprintf(2, 'Error reading audio file: %s\n', ME.message);
        Fs = []; 
        bitDepth = []; 
        bitRate = []; 
        numChannels = []; 
        totalSamples = []; 
    end
end
%% ---Convert to Frequency Domain ---
function [f, dB_Rec_shifted, dB_Han_shifted, dB_Ham_shifted] = compute_freq_response(Fs, W_Rec, W_Han, W_Ham)
% COMPUTE_FREQ_RESPONSE Calculates the shifted and normalized log-magnitude
%                       frequency response for three window functions.
%
%   [f, dB_Rec_shifted, dB_Han_shifted, dB_Ham_shifted] = compute_freq_response(Fs, W_Rec, W_Han, W_Ham)
%
%   Inputs:
%       Fs: Sampling frequency (Hz).
%       W_Rec, W_Han, W_Ham: Time-domain window vectors (must be the same length N).
%
%   Outputs:
%       f: Frequency vector for plotting (perfectly centered around 0 Hz).
%       dB_Rec_shifted, dB_Han_shifted, dB_Ham_shifted: Shifted log-magnitude
%           spectra (in dB, normalized to 0 dB peak).

    % Get the window length N
    N = length(W_Rec);
    
    %% --- 1. Apply FFT and compute magnitude ---
    fft_Rec = abs(fft(W_Rec,N));
    fft_Han = abs(fft(W_Han,N));
    fft_Ham = abs(fft(W_Ham,N));
   

    
    %% --- 2. Normalize the magnitude spectrum so the peak is 0 dB ---
    % Normalization is done by dividing by the maximum value before taking log10
    % A small epsilon is added to avoid log(0) which produces -Inf
    epsilon = 1e-12; 
    
    dB_Rec = 20 * log10(fft_Rec + epsilon);
    dB_Han = 20 * log10(fft_Han);
    dB_Ham = 20 * log10(fft_Ham);

    
    %% --- 3. Shift the zero-frequency component to the center (DC at f=0) ---
    dB_Rec_shifted = fftshift(dB_Rec);
    dB_Han_shifted = fftshift(dB_Han);
    dB_Ham_shifted = fftshift(dB_Ham);
    
    %% --- 4. Create the CORRECT frequency vector for the x-axis ---
    % For an even length N (like 1024), the frequency vector should span 
    % from -Fs/2 up to (but excluding) Fs/2.
    f_index = (-N/2 : N/2 - 1);
    f = f_index * (Fs / N);

end
%% ---plot windows in frequency---
function fig = plot_freq_windows(Fs, f, dB_Rec_shifted, dB_Han_shifted, dB_Ham_shifted)
% PLOT_FREQ_WINDOWS Plots the shifted and normalized log-magnitude spectra
%                     of the three window functions in separate subplots.
%
%   fig = plot_freq_windows(Fs, f, dB_Rec_shifted, dB_Han_shifted, dB_Ham_shifted)
%
%   Inputs:
%       Fs: Sampling frequency (Hz).
%       f: Frequency vector.
%       dB_Rec_shifted, dB_Han_shifted, dB_Ham_shifted: Shifted log-magnitude spectra.
%
%   Output:
%       fig: The handle of the created MATLAB figure.
    
    MAGNITUDE_FLOOR = -400; 
    % Zoom limit: +/- Fs/16 (e.g., +/- 1000 Hz for Fs=16000)
    X_LIMIT = Fs/10;

    % Apply clipping to the dB values for better visualization
    dB_Rec_shifted = max(dB_Rec_shifted, MAGNITUDE_FLOOR);
    dB_Han_shifted = max(dB_Han_shifted, MAGNITUDE_FLOOR);
    dB_Ham_shifted = max(dB_Ham_shifted, MAGNITUDE_FLOOR);

    % Create the figure and capture its handle
    fig = figure('Name', 'Window Functions in Frequency Domain');
    
    % --- Subplot 1: Rectangular Window ---
    subplot(3, 1, 1);
    
    plot(f, dB_Rec_shifted, 'b');
    title('Rectangular Window Frequency Response ($W_{Rec}$)', 'Interpreter', 'latex');
    ylabel('Magnitude (dB)');
    xlim([-X_LIMIT, X_LIMIT]);  
    grid on;
    
    % --- Subplot 2: Hanning Window ---
    subplot(3, 1, 2);
    plot(f, dB_Han_shifted, 'r');
    title('Hanning Window Frequency Response ($W_{Han}$)', 'Interpreter', 'latex');
    ylabel('Magnitude (dB)');
    xlim([-X_LIMIT, X_LIMIT]);  
    grid on;
    
    % --- Subplot 3: Hamming Window ---
    subplot(3, 1, 3);
    plot(f, dB_Ham_shifted, 'g');
    title('Hamming Window Frequency Response ($W_{Ham}$)', 'Interpreter', 'latex');
    xlabel('Frequency (Hz)');
    ylabel('Magnitude (dB)');
    xlim([-X_LIMIT, X_LIMIT]);  
    grid on;
    
    % Adjust layout for better visualization
    sgtitle(['Frequency Domain Analysis of Windows (N=', num2str(length(f)), ', Fs=', num2str(Fs), ')'], 'FontSize', 14);
end
%% --- LPC_MATRIX_SOLUTION ---
function [A_matrix, E_vector,P] = lpc_matrix_solution(R_matrix)
%LPC_MATRIX_SOLUTION Solves the Yule-Walker (Normal) equations for LPC coefficients 
%   for multiple frames using direct matrix inversion.
%
%   [A_MATRIX, E_VECTOR] = lpc_matrix_solution(R_MATRIX)
%
% Inputs:
%   R_matrix : Matrix where each ROW contains the autocorrelation 
%              coefficients for one frame: [R[0], R[1], ..., R[P]].
%
% Outputs:
%   A_matrix : Matrix where each ROW contains the final filter denominator 
%              coefficients: [ a[1], a[2], ..., a[P]].
%   E_vector : Column vector containing the minimum mean-squared error (E_P) 
%              for each frame.

    % --- 1. Setup and Pre-allocation ---
    [num_frames, P_plus_1] = size(R_matrix);
    P = P_plus_1 - 1; % Prediction order P
    
    % A_matrix will store the final filter denominator coefficients A = [ a1, ...]
    A_matrix = zeros(num_frames, P);
    
    % E_vector stores the final prediction error E_P
    E_vector = zeros(num_frames, 1);
    
    fprintf('Solving LPC system of order p = %d for %d frames via Matrix Inversion...\n', P, num_frames);

    % --- 2. Process Each Frame ---
    for k = 1:num_frames
        R_vector = R_matrix(k, :); % R_vector = [R(0), R(1), ..., R(P)]
        
        % R_0 is R(0)
        R_0 = R_vector(1); 
        
        % Check for zero energy frame
        if R_0 < 1e-10
            A_matrix(k, :) = [1, zeros(1, P)]; 
            E_vector(k) = 0;
            continue; 
        end
        
        % --- 3. Construct the Autocorrelation Matrix (R) and Vector (-r) ---
        
        % The Toeplitz Matrix R_P (size P x P) from R(0) to R(P-1)
        % R_vector(1:P) are R(0) to R(P-1)
        R_P_matrix = toeplitz(R_vector(1:P), R_vector(1:P));
        
        % The right-hand-side vector (-r_P) (size P x 1)
        % r_P = [R(1); R(2); ...; R(P)]. The RHS is -r_P.
        % R_vector(2:end) are R(1) to R(P)
        r_P_rhs = R_vector(2:end)';
        
        % --- 4. Solve for Predictor Coefficients (a) ---
        % Solve the linear system: R_P_matrix * a_coeffs = -r_P
        % a_coeffs = [a1, a2, ..., aP]
        a_predictor_coeffs = R_P_matrix \ r_P_rhs;
        
        % --- 5. Calculate the Minimum Mean-Squared Prediction Error (E_P) ---
        % E_P = R(0) + sum_{k=1}^{P} a_k * R(k) = R(0) + a' * r_P
        % Note: R_vector(2:end)' is the vector r_P
        E_P_error = R_0 + a_predictor_coeffs' * R_vector(2:end)';
        
        % --- 6. Store Final Results ---
        % The filter denominator coefficients are A = [ a1, a2, ..., aP]
        A_matrix(k, :) = [ a_predictor_coeffs'];
        E_vector(k) = E_P_error;
    end
    
    fprintf('Matrix Solution Complete. (Filter A(z) coefficients returned: [a1, ..., aP])\n');
end
%% --- PRINT R Matrix ---
function print_R_matrix(R_matrix)
% PRINT_R_VECTOR prints the autocorrelation matrix R in a clean,
% human-readable format, specifying the lag indices for each frame.
%
% This function is updated to handle a matrix input (multiple frames).
%
% Inputs:
%   R_matrix: The autocorrelation matrix, where each ROW is a frame's
%             autocorrelation vector R = [R(0), R(1), ..., R(p)]
    
    % Get dimensions of the R matrix
    [num_frames, P_plus_1] = size(R_matrix);
    % Determine the prediction order 'p'
    P_order = P_plus_1 - 1;
    
    % --- 1. Construct the R(lag) labels (only needs to be done once) ---
    labels = cell(1, P_plus_1);
    for k = 0:P_order
        labels{k+1} = sprintf('R(%d)', k);
    end
    labels_str = strjoin(labels, ', ');
    
    fprintf('\n--- Autocorrelation Analysis: R[0] to R[%d] for %d Frames ---\n', P_order, num_frames);
    
    % --- 2. Loop through each frame (row of the matrix) and print ---
    for frame_idx = 1:num_frames
        % Extract the R vector for the current frame
        R_vector = R_matrix(frame_idx, :);
        
        % Construct the R values string (formatted to 4 decimal places)
        R_values_str = sprintf('%.4f, ', R_vector);
        
        % Remove the trailing comma and space
        R_values_str = R_values_str(1:end-2); 
        
        % Print the final output string for the current frame
        fprintf('Frame %d R = [%s] = [%s]\n', frame_idx, labels_str, R_values_str);
    end
    fprintf('------------------------------------------------------------------\n');
end
%% --- LPC results  ---
function figHandle = print_lpc_matrix_results(X_frames, A_matrix, E_vector, R_matrix)
%PRINT_LPC_MATRIX_RESULTS Generates a MATLAB figure containing a formatted 
%   table of LPC analysis results. This version formats all numeric data
%   to strings to ensure compatibility with various MATLAB versions.
%
% Inputs:
%   X_frames: Matrix where each ROW contains the raw signal samples for the frame.
%   A_matrix: Matrix where each ROW contains the LPC predictor 
%             coefficients: [a[1], a[2], ..., a[P]].
%   E_vector: Column vector containing the minimum mean-squared error (E_P) 
%             for each frame.
%   R_matrix: Matrix where each ROW contains the autocorrelation 
%             coefficients: [R[0], R[1], ..., R[P]].
%
% Output:
%   figHandle: Handle to the generated figure.

    % --- 1. Determine Dimensions and Order ---
    [num_frames, P] = size(A_matrix);
    
    if num_frames == 0
        figHandle = [];
        fprintf('--- LPC Results ---\n');
        fprintf('No frames processed. A_matrix is empty.\n');
        return;
    end
    
    [~, num_samples_per_frame] = size(X_frames);
    MAX_SAMPLES_TO_SHOW = 6; % Show up to 6 samples
    samples_to_print = min(num_samples_per_frame, MAX_SAMPLES_TO_SHOW);
    
    % --- 2. Create Headers ---
    headers = {'Frame Index'};
    
    % Add Samples Header
    sample_header_str = sprintf('Samples (first %d)', samples_to_print);
    if num_samples_per_frame > MAX_SAMPLES_TO_SHOW
        sample_header_str = [sample_header_str, ' ...'];
    end
    headers = [headers, sample_header_str];

    % Add R Coefficients Headers
    for p_idx = 0:P
        headers = [headers, sprintf('R(%d)', p_idx)];
    end
    
    % Add Error Header
    headers = [headers, 'Error (E_P)'];
    
    % Add A Coefficients Headers
    for p_idx = 1:P
        headers = [headers, sprintf('a%d', p_idx)];
    end
    
    % --- 3. Format Data into Cell Array of Strings ---
    % We convert all numerical data to strings with 4 decimal places for display.
    data_cell = cell(num_frames, length(headers));
    
    for k = 1:num_frames
        
        % 1. Frame Index (Formatted to String)
        data_cell{k, 1} = sprintf('%d', k);
        
        % 2. Samples String (Formatted for display)
        sample_str = '';
        for i = 1:samples_to_print
            % Use %s.0f for integer-like samples
            sample_str = [sample_str, sprintf('%.2f ', X_frames(k, i))];
        end
        if num_samples_per_frame > MAX_SAMPLES_TO_SHOW
            sample_str = [sample_str, '...'];
        end
        data_cell{k, 2} = strtrim(sample_str); 
        
        col_idx = 3; 

        % 3. R Coefficients (Formatted to String)
        for r_val = R_matrix(k, :)
            data_cell{k, col_idx} = sprintf('%.4f', r_val);
            col_idx = col_idx + 1;
        end
        
        % 4. Error (E_P) (Formatted to String)
        data_cell{k, col_idx} = sprintf('%.4f', E_vector(k));
        col_idx = col_idx + 1;
        
        % 5. A Coefficients (Formatted to String)
        for a_val = A_matrix(k, :)
            data_cell{k, col_idx} = sprintf('%.4f', a_val);
            col_idx = col_idx + 1;
        end
    end
    
    % --- 4. Create Figure and Uitable ---
    figHandle = figure('Name', 'LPC Analysis Results Table', 'NumberTitle', 'off', 'Color', 'w');
    
    u = uitable(figHandle);
    u.Data = data_cell;
    u.ColumnName = headers;
    u.RowName = {}; % Hide row numbers
    u.Units = 'normalized';
    u.Position = [0.02 0.02 0.96 0.93]; % Full figure size with margin
    u.FontSize = 10;
    
    % Since all data is now stored as strings, we don't need 'ColumnFormat' 
    % or 'ColumnDisplayFormat', increasing compatibility.
    
    % Set column widths for better fit
    col_widths = {50, 'auto'}; % Frame index width and Samples auto-width
    fixed_width = {70}; 
    for i = 3:length(headers)
        col_widths = [col_widths, fixed_width];
    end
    u.ColumnWidth = col_widths;

    % Add title to the figure
    title_str = sprintf('LPC Analysis Results Table (Prediction Order P=%d)', P);
    uicontrol('Style', 'text', 'String', title_str, ...
              'Units', 'normalized', 'Position', [0.3 0.95 0.4 0.05], ...
              'FontSize', 14, 'FontWeight', 'bold', 'BackgroundColor', 'w');

    % Maximize the figure for better view if it has many columns
    set(figHandle, 'WindowState', 'maximized');
    
    fprintf('\nLPC Results Table successfully generated in a figure window (handle: %d).\n', figHandle.Number);
end
%% --- Get Frames  ---
function frames = extract_frames(signal, frame_length, frame_shift)
%EXTRACT_FRAMES Divides a 1D signal (e.g., speech) into frames, with zero-padding.
%
%   FRAMES = extract_frames(SIGNAL, FRAME_LENGTH, FRAME_SHIFT) divides the
%   input SIGNAL vector into a matrix of frames. Each ROW of the output
%   matrix FRAMES represents one frame. The last frame is zero-padded to
%   ensure the entire original signal is covered.
%
% Inputs:
%   signal       : The input signal vector (e.g., audio data).
%   frame_length : The length of each frame, in samples (N).
%   frame_shift  : The step size between the start of successive frames (the hop size), in samples (S).
%                  Overlap is calculated as N - S.
%
% Output:
%   frames       : A matrix where each ROW is a single frame of the signal.
%                  Size is [Num_Frames, FRAME_LENGTH].
%
% Note: This implementation uses zero-padding to ensure the entire original
%       signal is covered by the frames.

% --- 1. Input Validation and Setup ---
signal = signal(:); % Ensure the input signal is a column vector
signal_length = length(signal);

% Ensure parameters are positive integers and shift is <= length
if frame_length <= 0 || frame_shift <= 0 || frame_shift > frame_length
    error('Frame length (N) and shift (S) must be positive integers, and S must be <= N.');
end

% --- 2. Calculate Framing Parameters and Zero-Padding ---

% Calculate the total number of frames required (K).
% K = 1 + ceil((L - N) / S), where L=signal_length, N=frame_length, S=frame_shift
if signal_length < frame_length
    % If the signal is shorter than one frame, we still need one padded frame.
    num_frames = 1;
else
    % Standard calculation for zero-padded framing
    num_frames = 1 + ceil((signal_length - frame_length) / frame_shift);
end

% Calculate the total signal length required after padding (L_padded).
% L_padded = (K - 1) * S + N
required_length = (num_frames - 1) * frame_shift + frame_length;

% Calculate how many zeros to append
padding_amount = required_length - signal_length;

% Apply padding only if necessary
if padding_amount > 0
    signal = [signal; zeros(padding_amount, 1)];
end

% --- 3. Frame Extraction (as Columns first, for efficient memory access) ---

% Pre-allocate the output matrix with frames as columns: [N x K]
temp_frames_as_cols = zeros(frame_length, num_frames);

% Loop through and extract each frame
for k = 1:num_frames
    % Calculate the starting index for the current frame
    start_index = 1 + (k - 1) * frame_shift;
    
    % The ending index is calculated relative to the start index
    end_index = start_index + frame_length - 1;
    
    % Extract the segment and store it as a column in the temporary matrix
    temp_frames_as_cols(:, k) = signal(start_index:end_index);
end

% --- 4. Transpose to finalize output: Frames as Rows ---
% Transpose the matrix from [N x K] to [K x N]
frames = temp_frames_as_cols.';

end
%% --- Plot Frames  ---
function fig_handle = plot_frames(s, frames, frame_length, frame_shift, Fs)
%PLOT_FRAMES Plots the original signal and visualizes individual frames using subplots.
%
%   FIG_HANDLE = plot_frames(S, FRAMES, FRAME_LENGTH, FRAME_SHIFT, Fs)
%   Generates a figure with two subplots:
%   1. Top Subplot: Time-domain plot of the entire signal (S) with markers
%      showing the start of each frame.
%   2. Bottom Subplot: Overlays the first 5 extracted frames to visualize 
%      the content and overlap.
%
% Inputs:
%   s            : The original input signal vector.
%   frames       : The frame matrix, where each ROW is a frame (size [K x N]).
%   frame_length : The length of each frame, in samples (N).
%   frame_shift  : The hop size (step size) between frames, in samples (S).
%   Fs           : The sampling frequency, in Hz (used for time scaling).
%
% Output:
%   fig_handle   : Handle to the generated figure.

    % Ensure input signal is a column vector
    s = s(:);
    signal_length = length(s);
    num_frames = size(frames, 1); 
    
    % --- Time Axis Setup ---
    time_s = (0:signal_length-1) / Fs; % Time vector for the original signal in seconds
    start_indices = 1 + (0:(num_frames-1)) * frame_shift;
    start_time = (start_indices - 1) / Fs;
    
    % Get the max amplitude of the signal for consistent scaling
    max_amp = max(abs(s)) * 1.05;

    % --- 1. Create Figure ---
    fig_handle = figure;
    set(fig_handle, 'Color', 'w'); % Set background to white

    % --------------------------------------------------------------------
    % Subplot 1: Full Signal Visualization
    % --------------------------------------------------------------------
    subplot(2, 1, 1);
    plot(time_s, s, 'k', 'LineWidth', 1.5);
    hold on;
    
    % Plot vertical lines at the start of each frame
    for i = 1:num_frames
        t = start_time(i);
        
        % Check for zero-padded frame (last frame)
        is_padded = start_indices(i) + frame_length - 1 > signal_length;
        
        if is_padded
            % Last zero-padded frame (red, dotted)
            plot([t, t], [-max_amp, max_amp], 'r:', 'LineWidth', 0.8, 'HandleVisibility', 'off');
        else
            % Normal frames (blue, dashed)
            plot([t, t], [-max_amp, max_amp], 'b--', 'LineWidth', 1, 'HandleVisibility', 'off');
        end
        
        % Label the frame start
        if i <= 5 || i == num_frames
             text(t, max_amp, sprintf('F%d', i), 'VerticalAlignment', 'bottom', 'HorizontalAlignment', 'center', 'FontSize', 8, 'Color', 'm');
        end
    end

    % Styling
    title('1. Full Signal with Frame Start Markers', 'FontSize', 12, 'FontWeight', 'bold');
    xlabel('Time (s)', 'FontSize', 10);
    ylabel('Amplitude', 'FontSize', 10);
    grid on;
    xlim([0, time_s(end)]); 
    ylim([-max_amp, max_amp]);
    hold off;

    % --------------------------------------------------------------------
    % Subplot 2: First Few Frames Overlaid
    % --------------------------------------------------------------------
    subplot(2, 1, 2);
    
    % Determine how many frames to plot in the detail view
    frames_to_plot = min(5, num_frames); 
    
    if frames_to_plot > 0
        % Time vector for a single frame (relative time from 0 to N-1 samples)
        time_frame = (0:frame_length-1) / Fs;
        
        % Define colors for different frames
        colors = lines(frames_to_plot); 
        
        for i = 1:frames_to_plot
            % Plot the frame data. Frames are rows, so frames(i, :)
            plot(time_frame, frames(i, :), 'Color', colors(i, :), 'LineWidth', 1, 'DisplayName', sprintf('Frame %d', i));
            hold on;
        end
        
        % Styling
        title(sprintf('2. Detail View: First %d Extracted Frames Overlaid', frames_to_plot), 'FontSize', 12, 'FontWeight', 'bold');
        xlabel('Time within Frame (s)', 'FontSize', 10);
        ylabel('Amplitude', 'FontSize', 10);
        legend('Location', 'southeast');
        grid on;
        xlim([0, time_frame(end)]);
        ylim([-max_amp, max_amp]);
    else
        % Handle case where signal is too short
        text(0.5, 0.5, 'No frames extracted (Signal too short).', 'HorizontalAlignment', 'center');
    end

    hold off;
end
%% --- Plot Frames grid  ---
function fig_handle = plot_frame_grid(frames, Fs)
%PLOT_FRAME_GRID Plots the first N frames in a grid of subplots.
%
%   FIG_HANDLE = plot_frame_grid(FRAMES, Fs)
%   Generates a figure showing the waveform of the first 12 extracted 
%   frames, each in its own subplot, arranged in a 3x4 grid. This is useful 
%   for inspecting the exact content and overlap of the first few frames.
%
% Inputs:
%   frames       : The frame matrix, where each ROW is a frame.
%   Fs           : The sampling frequency, in Hz.
%
% Output:
%   fig_handle   : Handle to the generated figure.

    % --- Configuration ---
    max_frames_to_show = 12;
    rows = 3;
    cols = 4;
    
    num_frames = size(frames, 1);
    
    if num_frames == 0
        warning('PLOT_FRAME_GRID: No frames available to plot (Signal too short).');
        return;
    end

    % Determine the number of frames to actually plot
    frames_to_plot = min(max_frames_to_show, num_frames); 
    
    % --- Create Figure ---
    fig_handle = figure;
    % Make the figure large for better readability of the subplots
    set(fig_handle, 'Color', 'w', 'Units', 'normalized', 'OuterPosition', [0.1 0.1 0.8 0.8]); 
    
    % Get max amplitude across all selected frames for consistent Y-axis scaling
    max_amp = max(abs(frames(1:frames_to_plot, :)), [], 'all') * 1.05;

    % Time vector for a single frame (relative time from 0 to N-1 samples)
    frame_length = size(frames, 2);
    time_frame = (0:frame_length-1) / Fs;

    % Loop through the frames and generate subplots
    for i = 1:frames_to_plot
        % Select the subplot position
        subplot(rows, cols, i);
        
        % Plot the individual frame
        plot(time_frame, frames(i, :), 'b', 'LineWidth', 1.2);
        
        % Styling
        title(sprintf('Frame %d', i), 'FontSize', 10, 'FontWeight', 'bold');
        xlabel('Time (s)', 'FontSize', 8);
        ylabel('Amplitude', 'FontSize', 8);
        
        % Set consistent limits for all frames
        xlim([0, time_frame(end)]);
        ylim([-max_amp, max_amp]);
        grid on;
    end
    
    % Super title for the entire figure
    sgtitle(sprintf('Detailed Visualization: First %d Individual Speech Frames (%d samples/frame)', frames_to_plot, frame_length), ...
            'FontSize', 14, 'FontWeight', 'bold');

end
%% --- calculate autocorrelation  ---
function R_matrix = calculate_autocorr_frames(frames, P)
%CALCULATE_AUTOCORR_FRAMES Calculates the autocorrelation coefficients for each frame.
%
%   R_MATRIX = calculate_autocorr_frames(FRAMES, P) computes the first P+1
%   autocorrelation coefficients (R[0] to R[P]) for every frame in the input
%   matrix FRAMES.
%
% Inputs:
%   frames : Matrix where each ROW is a single signal frame (K x N).
%   P      : The order of the Linear Predictive Coding (LPC order). The 
%            output R_matrix will have P+1 columns (R[0] to R[P]).
%
% Output:
%   R_matrix : A matrix where each ROW contains the autocorrelation 
%              coefficients for one frame. Size is [K x (P+1)].

    % --- 1. Setup and Pre-allocation ---
    num_frames = size(frames, 1);
    frame_length = size(frames, 2);
    
    % The output matrix will have K rows (frames) and P+1 columns (R[0]..R[P])
    R_matrix = zeros(num_frames, P + 1);
    
    % --- 2. Iterative Autocorrelation Calculation ---
    % Loop through each frame (row of the input matrix)
    for k = 1:num_frames
        % Get the current frame (ensure it's treated as a row vector)
        current_frame = frames(k, :);
        
        % Calculate the full autocorrelation sequence R_full using xcorr
        % R_full will have 2*N - 1 elements.
        R_full = xcorr(current_frame);
        
        % The lag 0 correlation (R[0]) is located at the center of R_full.
        % For a sequence of length N, xcorr gives 2N-1 values.
        % The center index (lag 0) is N.
        lag0_index = frame_length;
        
        % Extract the positive lags from R[0] up to R[P].
        % This corresponds to indices: R[lag0_index] to R[lag0_index + P]
        autocorr_coeffs = R_full(lag0_index : lag0_index + P);
        
        % Store the resulting P+1 coefficients in the output matrix
        R_matrix(k, :) = autocorr_coeffs;
    end
    
end
%% --- Pre-empahsis signal  ---
function s_emph = pre_emphasis_signal(s, alpha)
%PRE_EMPHASIS_FILTER_SIGNAL Applies a first-order pre-emphasis filter to a signal.
%
%   s_emph = pre_emphasis_filter_signal(s, alpha) applies the pre-emphasis
%   filter defined by H(z) = 1 - alpha*z^-1 to the input signal s.
%   This is equivalent to the time-domain equation:
%   s_emph[n] = s[n] - alpha * s[n-1]
%
% Inputs:
%   s     - The input time-domain signal (vector).
%   alpha - The pre-emphasis constant (e.g., 0.96 for speech analysis).
%
% Output:
%   s_emph - The pre-emphasized output signal (vector).
%
% The first sample of the output signal is s_emph[1] = s[1] - alpha*s[0].
% MATLAB's 'filter' function correctly handles the implied initial condition s[0]=0.

    % Define the coefficients for the FIR filter H(z) = B(z) / A(z)
    % B(z) is the numerator polynomial: B = [1, -alpha]
    % A(z) is the denominator polynomial: A = [1]
    B = [1, -alpha];
    A = 1;

    % Apply the filter using MATLAB's 'filter' function.
    s_emph = filter(B, A, s);

    %results 
    fprintf('\n--- Problem 3b: LPC Analysis w/ Pre-emphasis (alpha=%.2f) ---\n', alpha);
    fprintf('Original Signal s[n]: [%s]\n', num2str(s));
    fprintf('Pre-emphasized s_emph[n]: [%s]\n', num2str(s_emph, 4));
end
%% --- Calculate Pole Response ---
function [A_coeffs, H_mag, W] = calculate_all_pole_response(Poles, Fs, N_points)
% CALCULATE_ALL_POLE_RESPONSE Calculates the coefficients and magnitude 
% spectrum of an all-pole system H(z) = 1/A(z).
%
%   Inputs:
%       Poles: Array of the system's poles.
%       Fs: Sampling frequency in Hz.
%
%   Outputs:
%       A_coeffs: Denominator coefficients A(z) = 1 + a1*z^-1 + ...
%       H_mag: The magnitude of the frequency response H(e^j\omega).

    % 1. Calculate the denominator coefficients A(z) = 1 + a1*z^-1 + ...
    % The 'poly' function takes the roots (poles) and returns the 
    % coefficients of the polynomial.
    A_coeffs = poly(Poles);
    
    % Create the frequency vector (w) for plotting 
    W = (0:N_points-1) * (Fs/2) / N_points; 
    
    % freqz(Numerator, Denominator, N_points, Sampling_Frequency)
    [H, ~] = freqz(1, A_coeffs, N_points, Fs); 
    
    % Store the magnitude (abs(H))
    H_mag = abs(H);

end
%% --- Poles Plot
function fig_handle =plot_pole_spectrum(Fs, w, H_mag)
% PLOT_POLE_SPECTRUM Plots the magnitude spectrum of an all-pole system in dB.
%
%   Inputs:
%       Fs: Sampling frequency in Hz.
%       w: Frequency vector in Hz.
%       H_mag: Magnitude of the frequency response H(e^j\omega).

    % Plotting the magnitude in dB
    fig_handle= figure('Name', 'Problem 4 Spectrum Plot');
    plot(w, 20*log10(H_mag), 'LineWidth', 2, 'Color', [0.1 0.5 0.7]);
    
    grid on;
    title('Magnitude Spectrum of 8th-Order All-Pole System (Vocal Tract Model)');
    xlabel('Frequency (Hz)');
    ylabel('Magnitude (dB)');
    xlim([0, Fs/2]); % Plot only up to Nyquist frequency (8000 Hz)
    set(gca, 'FontSize', 10);
    hold on; % Keep the plot open so the main script can add formant markers
end
%% --- BW calculation ---
function [Formants_Hz, Bandwidths_Hz] = estimate_and_plot_formants(Poles, Fs, H_mag)
% ESTIMATE_AND_PLOT_FORMANTS Calculates the formant frequencies and bandwidths 
% from the system poles and annotates the current magnitude spectrum plot.
%
%   Inputs:
%       Poles: Array of the system's poles.
%       Fs: Sampling frequency in Hz.
%       H_mag: Magnitude of the frequency response H(e^j\omega) (used for plotting limits).
%
%   Outputs:
%       Formants_Hz: Array of calculated formant frequencies.
%       Bandwidths_Hz: Array of calculated formant bandwidths.
    
    % --- Core Calculation Logic ---

    % 1. Isolate upper-half poles and sort by angle (frequency)
    Poles_upper_half = Poles(imag(Poles) > 0); 
    [~, sortIdx] = sort(angle(Poles_upper_half));
    Poles_sorted = Poles_upper_half(sortIdx);

    num_formants = length(Poles_sorted);
    Formants_Hz = zeros(num_formants, 1);
    Bandwidths_Hz = zeros(num_formants, 1);

    % --- Output Header ---
    fprintf('------------------------------------------------------------------------------------------------\n');
    fprintf('Problem 4b: Formant and Bandwidth Estimation (Fs = %d Hz)\n', Fs);
    fprintf('------------------------------------------------------------------------------------------------\n');
    fprintf(' i |     Pole (Real, Imag)      | Pole Radius (r) | Pole Angle (theta rad) | Formant F_i (Hz) | Bandwidth B_i (Hz)\n');
    fprintf('---|----------------------------|-----------------|------------------------|------------------|--------------------\n');

    % --- Loop through poles to calculate and plot ---
    H_db = 20*log10(H_mag);
    min_db = min(H_db); 
    max_db = max(H_db);

    for k = 1:num_formants
        p = Poles_sorted(k);
        r = abs(p);
        theta = angle(p);
        
        % Formant Frequency (F_k) in Hz: F_k = (theta / 2*pi) * Fs
        Fk = (theta / (2*pi)) * Fs;
        
        % Bandwidth (B_k) in Hz: B_k = - (Fs / pi) * log(r)
        Bk = - (Fs / pi) * log(r);
        
        Formants_Hz(k) = Fk;
        Bandwidths_Hz(k) = Bk;

        % Print detailed results to console
        fprintf('%2d | %8.6f + %8.6f j | %11.6f | %15.6f | %15.2f | %17.2f\n', k, real(p), imag(p), r, theta, Fk, Bk);

        % Plotting the Formant frequencies as vertical lines on the spectrum
        % NOTE: The plot_pole_spectrum function must be called beforehand to setup the figure with 'hold on'
        plot([Fk, Fk], [min_db, max_db], '--r', 'HandleVisibility','off');
    end

    % --- Annotate Plot and Final Summary ---
    
    % Labeling the Formants on the plot
    for k = 1:num_formants
        text(Formants_Hz(k), max_db - (k)*1, ['F', num2str(k), ': ', num2str(Formants_Hz(k), '%.0f'), ' Hz'], ...
            'Color', 'red', 'FontSize', 8, 'HorizontalAlignment', 'center');
    end
    legend('System Spectrum', 'Location', 'NorthEast');
    hold off;

    fprintf('------------------------------------------------------------------------------------------------\n');
    fprintf('Summary of Estimated Formant Frequencies (F1-F%d):\n[%s] Hz\n', num_formants, num2str(Formants_Hz.', '%.2f'));
    fprintf('Summary of Estimated Bandwidths (B1-B%d):\n[%s] Hz\n', num_formants, num2str(Bandwidths_Hz.', '%.2f'));

end
%% --- Plot BW ---
function fig_handle =plot_BW_poles(Poles, Fs)
% PLOT_BW_POLES Calculates formant frequencies and bandwidths from poles 
% and displays the results in a MATLAB uitable figure.
%
%   Inputs:
%       Poles: Array of the system's poles.
%       Fs: Sampling frequency in Hz.
%
%   Outputs:
%       (Creates a new figure containing a uitable)

    % --- 1. Calculate Formant and Bandwidth Data ---

    % Isolate upper-half poles and sort by angle (frequency)
    Poles_upper_half = Poles(imag(Poles) > 0); 
    [~, sortIdx] = sort(angle(Poles_upper_half));
    Poles_sorted = Poles_upper_half(sortIdx);

    num_formants = length(Poles_sorted);
    % Initialize cell array: Index, Pole, Radius, Angle, Formant, Bandwidth
    data_cell = cell(num_formants, 6);

    for k = 1:num_formants
        p = Poles_sorted(k);
        r = abs(p);
        theta = angle(p);
        
        % Formant Frequency (F_k) in Hz: F_k = (theta / 2*pi) * Fs
        Fk = (theta / (2*pi)) * Fs;
        
        % Bandwidth (B_k) in Hz: B_k = - (Fs / pi) * log(r)
        Bk = - (Fs / pi) * log(r);
        
        % Populate the cell array with formatted strings for the table
        data_cell{k, 1} = num2str(k);
        data_cell{k, 2} = sprintf('%8.6f + %8.6f j', real(p), imag(p));
        data_cell{k, 3} = sprintf('%11.6f', r);
        data_cell{k, 4} = sprintf('%15.6f', theta);
        data_cell{k, 5} = sprintf('%15.2f', Fk);
        data_cell{k, 6} = sprintf('%17.2f', Bk);
    end

    % --- 2. Table Setup and Uitable Creation ---
    
    headers = {'i (Index)', 'Pole (Real, Imag)', 'Pole Radius (r)', ...
               'Pole Angle (theta rad)', 'Formant F_i (Hz)', 'Bandwidth B_i (Hz)'};

    % Create Figure
    fig_handle = figure('Name', 'Formant and Bandwidth Results Table', 'NumberTitle', 'off', 'Color', 'w');
    
    % Create Uitable
    u = uitable(fig_handle);
    u.Data = data_cell;
    u.ColumnName = headers;
    u.RowName = {}; % Hide row numbers
    u.Units = 'normalized';
    u.Position = [0.02 0.02 0.96 0.93]; % Full figure size with margin
    u.FontSize = 10;
    
    % Set column widths for better fit
    col_widths = {50, 150, 100, 100, 100, 100}; 
    u.ColumnWidth = col_widths;
    
    % Add title to the figure
    title_str = sprintf('Formant and Bandwidth Estimation Results (Fs=%d Hz)', Fs);
    uicontrol('Style', 'text', 'String', title_str, ...
              'Units', 'normalized', 'Position', [0.1 0.95 0.8 0.05], ...
              'FontSize', 14, 'FontWeight', 'bold', 'BackgroundColor', 'w');

    % Maximize the figure for better view if it has many columns
    set(fig_handle, 'WindowState', 'maximized');
end
%% --- Recover Poles ---
function Recovered_Poles = recover_poles_from_coeffs(A_coeffs)
% RECOVER_POLES_FROM_COEFFS Calculates the roots (poles) of the denominator 
% polynomial A(z) given its coefficients.
%
%   Input:
%       A_coeffs: Array of the denominator coefficients 
%                 A(z) = A(1) + A(2)*z^-1 + ... + A(N)*z^-(N-1), where A(1)=1.
%
%   Output:
%       Recovered_Poles: Array of the system's poles.
%
% The MATLAB 'roots' function takes the polynomial coefficients and returns 
% the roots (poles).

    Recovered_Poles = roots(A_coeffs);

    % Optional: Sort the poles for cleaner display, often by magnitude or angle
    [~, sortIdx] = sort(angle(Recovered_Poles));
    Recovered_Poles = Recovered_Poles(sortIdx);

    fprintf('-----------------------------------------------------------\n');
    fprintf('Problem 5: Recovered Poles from A(z) Coefficients\n');
    fprintf('-----------------------------------------------------------\n');
    fprintf('Coefficient Order N = %d (System Order = %d)\n', length(A_coeffs), length(A_coeffs)-1);
    fprintf('Recovered Poles (Z-Plane Roots):\n');
    for i = 1:length(Recovered_Poles)
        p = Recovered_Poles(i);
        fprintf('  p%d: %8.6f + %8.6f j\n', i, real(p), imag(p));
    end
    fprintf('-----------------------------------------------------------\n');
end
%% --- Preprocess: pre-emphasis, framing, windowing ---
function [frames, win, N, hop] = speech_preprocess(x, Fs, params)
    N = round(params.frame_ms/1000 * Fs);
    hop = round(params.hop_ms/1000 * Fs);
    % pre-emphasis
    x_pre = filter([1 -params.preemph],1,x);
    % zero-pad and frame (use your extract_frames style: frames as rows)
    frames = extract_frames(x_pre, N, hop);
    % window vector (Hamming)
    win = hamming(N).';
    % apply window to each row
    for k=1:size(frames,1)
        frames(k,:) = frames(k,:) .* win;
    end
end
%% --- Analysis: LPC, gain ---
function [LPCCoef, gain] = speech_lpc_analysis(frames, p)

    K = size(frames,1);
    LPCCoef = zeros(p+1, K);
    gain = zeros(1,K);

    for k = 1:K
        fr = frames(k,:)';

        % --- 1) LPC estimation (with fallback)
        a = lpc(fr, p);   % returns row vector [1 a1 .. ap]

        % if LPC produced NaN/Inf → fallback to unity filter
        if any(~isfinite(a))
            a = [1, zeros(1,p)];
        end

        LPCCoef(:,k) = a(:);

        % --- 2) Residual calculation (safe)
        resid = filter(a, 1, fr);

        % Replace any NaN or Inf inside residual
        if any(~isfinite(resid))
            resid = zeros(size(resid));
        end

        % --- 3) Compute gain safely
        g = mean(resid.^2);

        if ~isfinite(g) || g < 1e-12
            g = 1e-12;  % minimal gain
        end

        gain(k) = sqrt(g);
    end
end
%% --- Pitch estimation ---
function [f0, peak_strength] = speech_pitch_estimation(frames, Fs, params, mode)
    K = size(frames,1);
    f0 = zeros(1,K);
    peak_strength = zeros(1,K);
    lag_min = floor(Fs/params.f0_max);
    lag_max = ceil(Fs/params.f0_min);
    for k=1:K
        fr = frames(k,:);
        % energy check
        if sum(fr.^2) < 1e-6
            f0(k)=0; peak_strength(k)=0; continue;
        end
        switch lower(mode)
            case 'basic'
                acf = xcorr(fr);
                mid = ceil(length(acf)/2);
                acf_pos = acf(mid+lag_min:mid+lag_max);
                [val, idx] = max(acf_pos);
                lag = idx + lag_min -1;
                r0 = acf(mid);
                if r0>0, norm_acf = val / r0; else norm_acf=0; end
                f0(k) = Fs/lag;
                peak_strength(k) = norm_acf;
           case 'centerclip' % Center-Clipped ACF 

                clip_thr = params.center_clip_pct * max(abs(fr));
                fr_cc = fr;
                
                % Center clipping implementation 
                
                % 1. Positive values: shift down by the threshold
                idx_pos = fr_cc > clip_thr;
                fr_cc(idx_pos) = fr_cc(idx_pos) - clip_thr;
                
                % 2. Negative values: shift up by the threshold
                idx_neg = fr_cc < -clip_thr;
                fr_cc(idx_neg) = fr_cc(idx_neg) + clip_thr;
                
                % 3. Values inside the clip range: set to zero (CORRECTED)
                idx_mid = abs(fr) <= clip_thr; % Check against the original frame 'fr'
                fr_cc(idx_mid) = 0; 
                
                acf = xcorr(fr_cc);
                mid = ceil(length(acf)/2);
                acf_pos = acf(mid+lag_min:mid+lag_max);
                [val, idx] = max(acf_pos);
                lag = idx + lag_min -1;
                r0 = acf(mid);
                if r0>0, norm_acf = val / r0; else norm_acf=0; end
                f0(k) = Fs/lag;
                peak_strength(k) = norm_acf;

            case 'cepstrum'
                % cepstral method (liftered)
                spec = fft(fr .* hamming(length(fr))', 2048);
                logmag = log(abs(spec)+eps);
                cep = ifft(logmag);
                % lifter range corresponds to pitch period between f0min..f0max
                qmin = floor(Fs/params.f0_max);
                qmax = ceil(Fs/params.f0_min);
                [val, idx] = max(abs(cep(qmin:qmax)));
                quef = idx + qmin -1;
                f0(k) = Fs/quef;
                peak_strength(k) = val / max(abs(cep)); 
            otherwise
                error('Unknown pitch mode %s',mode);
        end
        % limit f0 to sensible range
        if f0(k) < params.f0_min || f0(k) > params.f0_max
            f0(k) = 0;
            peak_strength(k)=0;
        end
    end
end
%% --- Voicing decision ---
function voiced = speech_voicing_decision(frames, f0_vec, acf_strength, params)
    K = size(frames,1);
    voiced = false(1,K);
    for k=1:K
        fr = frames(k,:);
        energy = sum(fr.^2);
        zcr = sum(abs(diff(fr>0))) / (2*length(fr));
        if f0_vec(k) > 0 && acf_strength(k) > params.acf_threshold && energy > 1e-6 && zcr < params.zcr_threshold
            voiced(k) = true;
        else
            voiced(k) = false;
        end
    end
end
%% --- Speech Generation ---
function exc = speech_generate_excitation(N, f0, voiced, gain, Fs, mode, resid_frame)
    if nargin<7, resid_frame = []; end
    exc = zeros(N,1);
    if voiced
        if f0>0
            T0 = round(Fs / f0);
            pos = 1;
            while pos <= N
                exc(pos) = 1;
                pos = pos + T0;
            end
        else
            exc = randn(N,1);
        end
        exc = exc * (gain + eps);
    else
        exc = randn(N,1) * (gain + eps);
    end
    % if residual provided and mode=='residual', use resid_frame shaped
    if nargin>=7 && ~isempty(resid_frame) && strcmp(mode,'residual')
        % resid_frame expected column vector length N
        exc = resid_frame(:) .* (gain + eps);
    end
end
%% --- Synthesis Basic ---
function y = speech_vocoder_synthesis_basic(LPCCoef, gain_vec, f0_vec, voiced_vec, win, hop, Fs, params)
    K = size(LPCCoef,2);
    N = length(win);
    outlen = (K-1)*hop + N;
    y = zeros(outlen,1);
    for k=1:K
        a_k = LPCCoef(:,k);
        exc = speech_generate_excitation(N, f0_vec(k), voiced_vec(k), gain_vec(k), Fs, 'impulse', []);
        synth_frame = filter(1, a_k, exc);  % synth by 1/A(z)
        idx = (1:N) + (k-1)*hop;
        y(idx) = y(idx) + (synth_frame .* win.');
    end
    % de-emphasis inverse
    y = filter(1, [1 -params.preemph], y);
end
%% --- Synthesis Residual --- 
function y = speech_vocoder_synthesis_residual(frames, LPCCoef, gain_vec, f0_vec, voiced_vec, win, hop, Fs, params)
    K = size(frames,1);
    N = length(win);
    outlen = (K-1)*hop + N;
    y = zeros(outlen,1);
    for k=1:K
        a_k = LPCCoef(:,k);
        % compute residual of the original windowed frame (inverse filter)
        fr = frames(k,:)';
        resid = filter(a_k,1,fr);  % residual = a(z)*frame
        % for voiced frames: pick a pitch-synchronous chunk of resid and replicate
        if voiced_vec(k) && f0_vec(k)>0
            T0 = round(Fs / f0_vec(k));
            % pick first T0 samples of residual (or center region)
            if T0 < 1, T0=1; end
            seg = resid(1:min(length(resid),T0));
            % build exc by tiling seg (with simple tapering)
            exc = zeros(N,1);
            pos = 1;
            while pos <= N
                L = min(length(seg), N-pos+1);
                exc(pos:pos+L-1) = exc(pos:pos+L-1) + seg(1:L);
                pos = pos + T0;
            end
            % small envelope to avoid discontinuities
            exc = exc .* hann_window_for_length(N);
            exc = exc * (gain_vec(k) + eps);
        else
            % unvoiced -> filtered noise shaped by LPC envelope (use inverse filter on noise)
            noise = randn(N,1) * (gain_vec(k)+eps);
            exc = noise;
        end
        % synth
        synth_frame = filter(1, a_k, exc);
        idx = (1:N) + (k-1)*hop;
        y(idx) = y(idx) + (synth_frame .* win.');
    end
    % de-emphasis inverse
    y = filter(1, [1 -params.preemph], y);
end

function w = hann_window_for_length(N)
    % small helper to create a tapered window matching synthesis windowing
    if N<=2
        w = ones(N,1);
    else
        w = hann(N);
        w = w(:);
    end
end
%% --- Smooth LPC ---
function LPCCoef_smoothed = smooth_lpc_coeffs(LPCCoef, window_len)
    [P1, K] = size(LPCCoef);
    LPCCoef_smoothed = LPCCoef;
    half = floor(window_len/2);
    for n=1:K
        L = max(1, n-half); R = min(K, n+half);
        LPCCoef_smoothed(:,n) = median(LPCCoef(:,L:R), 2);
    end
end
%% --- Plot  spectrograms ---
function fig =plot_vocoder_spectrograms(x, y_basic, y_improved, y_residual, Fs)
% PLOT_VOCODER_SPECTROGRAMS Creates a single figure with 4 subplots 
% showing the spectrograms of the original signal and the three vocoded 
% outputs.
%
% Inputs:
%   x           : Original signal
%   y_basic     : Basic Vocoder synthesized signal (Pulse/Noise)
%   y_improved  : Improved Vocoder synthesized signal (e.g., Smoothed LPC)
%   y_residual  : Residual Vocoder synthesized signal (AbS Residual)
%   Fs          : Sampling frequency
%   plots_folder: Directory path where the final figure will be saved.

    % Spectrogram parameters
    frame_len = round(0.03 * Fs); % 30 ms window
    overlap = round(0.02 * Fs);   % 20 ms overlap (10 ms hop)
    N_fft = 1024;                 % FFT points

    fig = figure('Name', 'Vocoder Spectrogram Comparison', 'Units', 'normalized', 'Position', [0.1 0.1 0.7 0.8]);

    % --- Subplot 1: Original Spectrogram ---
    subplot(4, 1, 1);
    spectrogram(x, frame_len, overlap, N_fft, Fs, 'yaxis');
    title('1. Original Signal Spectrogram');
    
    % --- Subplot 2: Basic Vocoder Spectrogram (Pulse/Noise) ---
    subplot(4, 1, 2);
    spectrogram(y_basic, frame_len, overlap, N_fft, Fs, 'yaxis');
    title('2. Basic Vocoder (Pulse/Noise Excitation)');

    % --- Subplot 3: Improved Vocoder Spectrogram (e.g., Smoothed LPC) ---
    subplot(4, 1, 3);
    spectrogram(y_improved, frame_len, overlap, N_fft, Fs, 'yaxis');
    title('3. Improved Vocoder (Smoothed LPC Coefficients)');

    % --- Subplot 4: Residual Vocoder Spectrogram (Analysis-by-Synthesis Residual) ---
    subplot(4, 1, 4);
    spectrogram(y_residual, frame_len, overlap, N_fft, Fs, 'yaxis');
    title('4. Residual Vocoder (Analysis-by-Synthesis Residual)');
    
    % Link X-axes (Time axes) for easier comparison
    linkaxes(findobj(fig, 'Type', 'Axes'), 'x');
    
    % Add a global title for the entire figure
    sgtitle('LPC Vocoder Synthesis Method Comparison');

end
%% --- Plot Pitch ---
function fig =plot_pitch_comparison(f0_basic, f0_cc, f0_cep, hop, Fs)
% PLOT_PITCH_COMPARISON Creates a single figure plotting F0 estimates from
% three different methods (Basic ACF, Center-Clip ACF, and Cepstrum).
%
% Inputs:
%   f0_basic    : F0 estimates from basic ACF (vector)
%   f0_cc       : F0 estimates from center-clip ACF (vector)
%   f0_cep      : F0 estimates from cepstrum method (vector)
%   hop         : Hop size in samples
%   Fs          : Sampling frequency
%   plots_folder: Directory path where the final figure will be saved.
    
    % Ensure all F0 vectors have the same length (should be equal to K, number of frames)
    K = length(f0_basic);
    
    % Calculate the time vector corresponding to the center of each frame
    % t_frames starts at time 0 and increases by hop/Fs for each frame
    t_frames = (0:K-1) * hop / Fs;
 fig = figure('Name','Pitch Track Comparison', 'Units', 'normalized', 'Position', [0.1 0.1 0.8 0.7]);
    
    % Combine all F0 data, removing NaN and non-positive values to determine 
    % a sensible dynamic range for the voiced segments.
    all_f0 = [f0_basic(:); f0_cc(:); f0_cep(:)];
    valid_f0 = all_f0(all_f0 > 0 & isfinite(all_f0));
    
    % Determine the common Y-axis limits
    if isempty(valid_f0)
        % Case 1: No voiced segments found (all F0s <= 0 or NaN)
        min_f0 = 0;
        max_f0 = 250; % Default typical F0 range for male speech
    else
        % Case 2: Voiced segments exist
        min_f0 = min(valid_f0);
        max_f0 = max(valid_f0);
    end
    
    % Set the final Y-axis range, ensuring it's slightly padded and always increasing
    % Ensure the lower bound is at least 0.
    y_min = max(0, min_f0 * 0.95 - 5);
    y_max = max_f0 * 1.05 + 5;
    
    % Final check: If y_max is not greater than y_min, enforce a default range
    if y_max <= y_min + 5
         y_min = 0;
         y_max = 250;
    end
    
    ylim_range = [y_min, y_max];
    
    % --- Subplot 1: Basic ACF Pitch Track ---
    subplot(3, 1, 1);
    plot(t_frames, f0_basic, 'b', 'LineWidth', 1.5); hold on;
    yline(0,'k:');
    title('1. Basic ACF F0 Estimate'); 
    ylabel('F0 (Hz)');
    ylim(ylim_range);
    grid on;

    % --- Subplot 2: Center-Clip ACF Pitch Track ---
    subplot(3, 1, 2);
    plot(t_frames, f0_cc, 'r', 'LineWidth', 1.5); hold on;
    yline(0,'k:');
    title('2. Center-Clip ACF F0 Estimate'); 
    ylabel('F0 (Hz)');
    ylim(ylim_range);
    grid on;

    % --- Subplot 3: Cepstrum Pitch Track ---
    subplot(3, 1, 3);
    plot(t_frames, f0_cep, 'k', 'LineWidth', 1.5); hold on;
    yline(0,'k:');
    title('3. Cepstrum F0 Estimate'); 
    xlabel('Time (s)');
    ylabel('F0 (Hz)');
    ylim(ylim_range);
    grid on;
    
    % Link X-axes (Time axes) for easier comparison
    linkaxes(findobj(fig, 'Type', 'Axes'), 'x');
    
    % Add a global title for the entire figure
    sgtitle('Comparison of Fundamental Frequency (F0) Estimation Methods');
   
end
%% --- VOcoder Error ---
function [error_basic, error_improved, error_residual, SDR_basic, SDR_improved, SDR_residual] ...
    = calculate_vocoder_error(x, y_basic, y_improved, y_residual)
% CALCULATE_VOCODER_ERROR Computes the reconstruction error metrics 
% (Normalized Root Mean Square Error - NRMSE) between the original signal (x) 
% and the three synthesized signals (y_basic, y_improved, y_residual).
%
% The function pads the original signal 'x' to match the length of the 
% longest synthesized signal, as typically the synthesized signal is longer 
% due to OLA and framing.
%
% Inputs:
%   x           : Original signal (vector)
%   y_basic     : Basic Vocoder output (vector)
%   y_improved  : Improved Vocoder output (vector)
%   y_residual  : Residual Vocoder output (vector)
%
% Outputs (Error % based on NRMSE):
%   error_basic    : NRMSE (%) for y_basic
%   error_improved : NRMSE (%) for y_improved
%   error_residual : NRMSE (%) for y_residual
%   SDR_basic      : Signal Distortion Ratio (dB) for y_basic
%   SDR_improved   : Signal Distortion Ratio (dB) for y_improved
%   SDR_residual   : Signal Distortion Ratio (dB) for y_residual

    % Ensure all inputs are column vectors
    x = x(:);
    y_basic = y_basic(:);
    y_improved = y_improved(:);
    y_residual = y_residual(:);
    
    L_x = length(x);
    L_basic = length(y_basic);
    L_improved = length(y_improved);
    L_residual = length(y_residual);
    
    % Find the maximum length required
    L_max = max([L_x, L_basic, L_improved, L_residual]);
    
    % --- 1. Pad Original Signal (x) ---
    if L_max > L_x
        padding_amount = L_max - L_x;
        x_padded = [x; zeros(padding_amount, 1)];
    else
        % If x is longer (unlikely for vocoder), truncate it to L_max
        x_padded = x(1:L_max);
    end
    
    % --- 2. Truncate Synthesized Signals if necessary (shouldn't happen 
    % if L_max came from one of them, but good for safety)
    y_basic_sync = y_basic(1:L_max);
    y_improved_sync = y_improved(1:L_max);
    y_residual_sync = y_residual(1:L_max);
    
    
    % --- 3. Define Metric Function ---
    
    % Calculation Function (using NRMSE and SDR)
    % NRMSE (%) = ||x - y||_2 / ||x||_2 * 100%
    % SDR (dB) = 10 * log10( ||x||_2^2 / ||x - y||_2^2 )
    
    function [nrmse_pct, sdr_db] = calculate_metrics(ref_sig, test_sig)
        % Energy of the reference signal (Original)
        P_sig = sum(ref_sig.^2); 
        
        % Energy of the error signal (Noise)
        err_sig = ref_sig - test_sig;
        P_err = sum(err_sig.^2);
        
        if P_sig < eps % Handle near-zero energy (division by zero risk)
            nrmse_pct = 100;
            sdr_db = -Inf;
        else
            % Normalized Root Mean Square Error (NRMSE)
            nrmse_pct = sqrt(P_err) / sqrt(P_sig) * 100;
            
            % Signal Distortion Ratio (SDR) in dB
            sdr_db = 10 * log10(P_sig / P_err);
        end
    end
    
    % --- 4. Calculate Metrics for each vocoder ---
    
    [error_basic, SDR_basic] = calculate_metrics(x_padded, y_basic_sync);
    [error_improved, SDR_improved] = calculate_metrics(x_padded, y_improved_sync);
    [error_residual, SDR_residual] = calculate_metrics(x_padded, y_residual_sync);

end
%% --- Plot VOcoder Error ---
function fig =plot_vocoder_metrics_table(error_basic, error_improved, error_residual, SDR_basic, SDR_improved, SDR_residual)
% PLOT_VOCODER_METRICS_TABLE Generates a figure containing a table of 
% vocoder reconstruction error metrics (NRMSE and SDR).
%
% Inputs:
%   error_basic    : NRMSE (%) for Basic Vocoder
%   error_improved : NRMSE (%) for Improved Vocoder
%   error_residual : NRMSE (%) for Residual Vocoder
%   SDR_basic      : SDR (dB) for Basic Vocoder
%   SDR_improved   : SDR (dB) for Improved Vocoder
%   SDR_residual   : SDR (dB) for Residual Vocoder
%   plots_folder   : Directory path where the final figure will be saved.

    % --- 1. Prepare Data for Table ---
    
    % Data Rows: Basic, Improved, Residual
    table_data = [...
        error_basic, SDR_basic;
        error_improved, SDR_improved;
        error_residual, SDR_residual];
    
    % Column Names
    column_names = {'Error Percentage (NRMSE %)', 'Signal Distortion Ratio (SDR dB)'};
    
    % Row Names (Vocoder Methods)
    row_names = {'Basic Vocoder (Pulse/Noise)', ...
                 'Improved Vocoder (Smoothed LPC)', ...
                 'Residual Vocoder (AbS Residual)'};

    % --- 2. Create Figure and Table ---
    
    fig = figure('Name', 'Vocoder Performance Metrics', 'Units', 'normalized', 'Position', [0.3 0.3 0.4 0.3]);
    
    % Create a MATLAB uitable object
    t = uitable(fig, ...
        'Data', table_data, ...
        'ColumnName', column_names, ...
        'RowName', row_names, ...
        'Units', 'normalized', ...
        'Position', [0 0 1 1], ... % Table fills the entire figure
        'FontName', 'Consolas', ...
        'FontSize', 12, ...
        'ColumnFormat', {'numeric', 'numeric'}, ...
        'ColumnWidth', {'auto', 'auto'}, ...
        'Tag', 'MetricsTable');

    % Set precision for display
    t.Data = round(t.Data, 3);
    
    % Add a title (optional, can also use sgtitle or annotation if preferred)
    annotation('textbox', [0.1 0.85 0.8 0.1], 'String', 'Vocoder Reconstruction Performance Metrics', ...
        'FontSize', 14, 'FontWeight', 'bold', 'EdgeColor', 'none', 'HorizontalAlignment', 'center');


end
%% --- Dataset Loader ---
function [feats, types, digits] = load_dataset(dirpath, params)
files = dir(fullfile(dirpath,'**','*.wav'));

N = numel(files);
feats = cell(N,1);
types = cell(N,1);
digits = cell(N,1);

for i = 1:N
    fp = fullfile(files(i).folder, files(i).name);
    [x,Fs] = audioread(fp);
    if size(x,2)>1, x = mean(x,2); end
    if Fs ~= params.fs_target
        x = resample(x, params.fs_target, Fs);
        Fs = params.fs_target;
    end

    % --- MFCC extraction ---
    feats{i} = compute_mfcc(x, Fs, params);

    % --- PARSE LABELS ---
    name = erase(files(i).name, ".wav");

    % Format: T##n_digit
    % First character = TYPE
    types{i} = name(1);

    % Digit is after _
    tok = split(name, "_");
    digits{i} = tok{end};
end
end
%% --- DTW Distance ---
function d = dtw_distance(X, Y, opts)
% X and Y are (D × T) MFCC matrices

% ---- Compute pairwise frame distances ----
Tx = size(X,2);
Ty = size(Y,2);

D = zeros(Tx,Ty);

for i = 1:Tx
    diff = X(:,i) - Y;
    D(i,:) = sqrt(sum(diff.^2,1));
end

% ---- Dynamic Programming ----
DTW = inf(Tx+1, Ty+1);
DTW(1,1) = 0;

for i = 2:(Tx+1)
    for j = 2:(Ty+1)
        DTW(i,j) = D(i-1,j-1) + min([
            DTW(i-1,j),   ... % insertion
            DTW(i,j-1),   ... % deletion
            DTW(i-1,j-1)  ... % match
        ]);
    end
end

d = DTW(Tx+1, Ty+1);
end

%% --- MFFC Matrix ---
function mfcc_feats = compute_mfcc(x, Fs, params)
% ---------------------------------------------------------------
% compute_mfcc
% Returns MFCC feature matrix [numFrames × numFeatures]
% including Δ and ΔΔ if requested.
%
% params fields:
%   fs_target
%   frame_ms
%   hop_ms
%   num_ceps
%   use_delta
%   normalize
% ---------------------------------------------------------------

%% === Parameters ===
N   = round(params.frame_ms/1000 * Fs);
hop = round(params.hop_ms/1000 * Fs);
num_ceps = params.num_ceps;

%% === Pre-emphasis ===
x = filter([1 -0.97], 1, x);

%% === Framing & Window ===
win = hamming(N, 'periodic');

% padding to avoid boundary issues
x = [x; zeros(N,1)];

numFrames = 1 + floor((length(x)-N)/hop);
mfcc_feats = zeros(numFrames, num_ceps);

%% === Mel Filterbank (once per function) ===
Nfft = 512;
mel_fb = mel_filterbank(Fs, Nfft, 26);   % 26 mel filters

%% === Process frame-by-frame ===
frame_id = 1;
for i = 1:hop:(length(x)-N)
    frame = x(i:i+N-1) .* win;

    % Power spectrum
    X = abs(fft(frame, Nfft)).^2;
    X = X(1:(Nfft/2+1));

    % Mel energies
    melE = mel_fb * X;
    melE = log(melE + eps);   % log energy

    % DCT → MFCC
    c = dct(melE);
    mfcc_feats(frame_id, :) = c(1:num_ceps);

    frame_id = frame_id + 1;
end

%% === Delta and Delta-Delta ===
if params.use_delta
    d1 = deltas(mfcc_feats')';
    d2 = deltas(d1')';
    mfcc_feats = [mfcc_feats, d1, d2];
end

%% === Utterance-level CMVN normalization ===
if params.normalize
    mfcc_feats = (mfcc_feats - mean(mfcc_feats, 1)) ./ (std(mfcc_feats, [], 1) + 1e-8);
end

end

% Delta coefficients
function d = deltas(x)
% x: D × T
[D,T] = size(x);
N = 2;
d = zeros(D,T);
den = 2 * sum((1:N).^2);

for t = 1:T
    acc = zeros(D,1);
    for n = 1:N
        t_plus  = min(T, t+n);
        t_minus = max(1, t-n);
        acc = acc + n*(x(:,t_plus) - x(:,t_minus));
    end
    d(:,t) = acc / den;
end
end

% Mel Filter
function H = mel_filterbank(Fs, Nfft, numFilters)
% Return mel filterbank matrix (numFilters × (Nfft/2+1))

Nfft2 = Nfft/2 + 1;
fmax = Fs/2;

mel = @(f) 1125*log(1 + f/700);
inv_mel = @(m) 700*(exp(m/1125) - 1);

mel_pts = linspace(mel(0), mel(fmax), numFilters+2);
f_pts = inv_mel(mel_pts);

bins = floor((Nfft+1) * f_pts / Fs);

H = zeros(numFilters, Nfft2);

for m = 1:numFilters
    left = bins(m);
    center = bins(m+1);
    right = bins(m+2);

    for k = left:center
        H(m,k+1) = (k-left) / (center-left);
    end
    for k = center:right
        H(m,k+1) = (right-k) / (right-center);
    end
end

H = max(H, 0);
end
%%

%% ---save figure to picture---
function figure_to_png(figHandle, filename, relative_save_path)
% FIGURE_TO_PNG Saves a specified MATLAB figure handle as a high-quality PNG file.
%
%   NOTE: This final version uses 'exportapp' (the recommended method for
%         figures containing UI components like uitable) to eliminate the 
%         "UI components will not be included" warning.
%
%   Inputs:
%       figHandle: Handle to the figure object.
%       filename: The base filename (e.g., 'problem1_time_domain').
%       relative_save_path: The desired save path relative to the *current* %                           function's directory (e.g., '../Data/Results/plot').
%
%   Output:
%       Saves the figure as a PNG file in the specified directory structure.
    
    % 1. Determine the current directory of this function
    current_file_path = mfilename('fullpath');
    current_dir = fileparts(current_file_path);
    
    % 2. Construct the absolute output directory path
    outputDir = fullfile(current_dir, relative_save_path);
    
    % 3. Ensure the output directory exists
    if ~exist(outputDir, 'dir')
        [success, message, ~] = mkdir(outputDir);
        if ~success
            fprintf(2, 'Error creating directory %s: %s\n', outputDir, message);
            return; 
        end
    end
    
    % 4. Construct the full file path for saving
    fullPath = fullfile(outputDir, [filename, '.png']);
    
    try
        % Force a redraw before saving to ensure everything is rendered
        drawnow; 
        
        % --- Final Robust Saving Method: Use exportapp ---
        % Using exportapp(figHandle, fullPath) is the most robust way to save 
        % figures containing uitables. It treats the figure as an application 
        % window, ensuring all UI elements are rendered correctly, and is 
        % compatible with figures containing only graphics as well.
        if exist('exportapp', 'file')
            % Use exportapp for universal, warning-free UI component export
            % The minimal syntax avoids the "Too many input arguments" error 
            % seen in the previous attempt.
            exportapp(figHandle, fullPath); 
            fprintf('Successfully saved figure (using exportapp) to: %s\n', fullPath);
        else 
            % Fallback to 'exportgraphics' if 'exportapp' is unavailable
            if exist('exportgraphics', 'file')
                 exportgraphics(figHandle, fullPath, 'Resolution', 300);
                 fprintf('Successfully saved figure (using exportgraphics fallback) to: %s\n', fullPath);
            else
                 % Final fallback for old MATLAB versions
                 set(figHandle, 'PaperPositionMode', 'auto');
                 print(figHandle, fullPath, '-dpng', '-r300');
                 fprintf('Successfully saved figure (using print fallback) to: %s\n', fullPath);
            end
        end
        
    catch ME
        % Print the actual error message that occurred during saving
        fprintf(2, 'Error saving figure %s: %s\n', filename, ME.message);
        disp('Saving failed. Check figure handle, file permissions, and MATLAB version compatibility.');
    end
end
